# 数据结构篇——常用数据结构

### 01. 数组（Array）

&#8195;数组是最基本的数据结构，在很多编程语言中都有着十分相似的性质。

#### 1.1 数组的优缺点：

**数组的优点：**

- 构建非常简单

- 能在 O(1) 的时间里根据数组的下标（index）查询某个元素

**数组的缺点：**

- 构建时必须分配一段连续的空间

- 查询某个元素是否存在时需要遍历整个数组，耗费 O(n) 的时间

- 删除和添加某个元素时，同样需要耗费 O(n) 的时间

&#8195;所以，在考虑是否应采用数组辅助算法时，需要考虑它的缺点是否会影响**时间复杂度和空间复杂度。**

#### 1.2 例题分析

>242. 有效的字母异位词
>
>给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词。 
>
>**示例 1:**
>
>```
>输入: s = "anagram", t = "nagaram"
>输出: true
>```
>
>
>**示例 2:**
>
>```
>输入: s = "rat", t = "car"
>输出: false
>```
>
>**说明:**
>你可以假设字符串只包含小写字母。
>
>**解释：**
>
>字母异位词，也就是两个字符串中的相同字符的数量要对应相等。

**解题思路：**

一个重要的前提“假设两个字符串只包含小写字母”，小写字母一共也就 26 个，因此：

- 方法一：可以利用两个长度都为 26 的字符数组来统计每个字符串中小写字母出现的次数，然后再对比是否相等；

- 方法二：可以只利用一个长度为 26 的字符数组，将出现在字符串 s 里的字符个数加 1，而出现在字符串 t 里的字符个数减 1，最后判断每个小写字母的个数是否都为 0。
- 方法三：方法二中的数组可以换成哈希表
- 方法四：排序后判断是否相等

|            | 方法一 | 方法二 | 方法三 | 方法四   |
| ---------- | ------ | ------ | ------ | -------- |
| 时间复杂度 | O(n)   | O(n)   | O(n)   | O(nlogn) |
| 空间复杂度 | O(1)   | O(1)   | O(1)   | O(1)     |

**尽管我们使用了额外的空间，但是空间的复杂性是 O(1)，因为无论 N 有多大，表的大小都保持不变。** 

>**进阶：**
>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
>
>**解答：**
>使用哈希表而不是固定大小的计数器。想象一下，分配一个大的数组来适应整个 Unicode 字符范围，这个范围可能超过 100万。哈希表是一种更通用的解决方案，可以适应任何字符范围。**这里就体现出了数组的缺点**

例题的具体代码见 [ExampleSolution/Python/242_isAnagram.py]( https://github.com/moonlighf/AlgorithmWithLeetCode/blob/master/DataStructure/ExampleSolution/Python/242_isAnagram.py )

### 02. 链表（LinkedList）

**单链表**：链表中的每个元素是一个单独的对象，所有对象通过每个元素中的引用字段链接在一起。

**双链表**：与单链表不同的是，双链表的每个结点中都含有两个引用字段。

#### 2.1 链表的优缺点：

**链表的优点：**

- 链表能灵活地分配内存空间；

- 能在 O(1) 时间内删除或者添加元素，前提是该元素的前一个元素已知，当然也取决于是单链表还是双链表，在双链表中，如果已知该元素的后一个元素，同样可以在 O(1) 时间内删除或者添加该元素。

**链表的缺点是：**

- 不像数组能通过下标迅速读取元素，每次都要从链表头开始一个一个读取；

- 查询第 k 个元素需要 O(k) 时间。

**应用场景：**如果要解决的问题里面需要很多快速查询，链表可能并不适合；如果遇到的问题中，数据的元素个数不确定，而且需要经常进行数据的添加和删除，那么链表会比较合适。**而如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合。**

#### 2.2 链表经典解题方法：

链表是实现很多复杂数据结构的基础，经典解法如下：

1. **利用快慢指针（有时候需要用到三个指针）**

典型题目例如：链表的翻转，寻找倒数第 k 个元素，寻找链表中间位置的元素，判断链表是否有环等等。

2. **构建一个虚假的链表头**

&#8195;一般用在要返回新的链表的题目中，比如，给定两个排好序的链表，要求将它们整合在一起并排好序。又比如，将一个链表中的奇数和偶数按照原定的顺序分开后重新组合成一个新的链表，链表的头一半是奇数，后一半是偶数。

&#8195;在这类问题里，如果不用一个虚假的链表头，那么在创建新链表的第一个元素时，我们都得要判断一下链表的头指针是否为空，也就是要多写一条 if else 语句。比较简洁的写法是创建一个空的链表头，直接往其后面添加元素即可，最后返回这个空的链表头的下一个节点即可。

**专家建议**：在解决链表的题目时，可以在纸上或者白板上画出节点之间的相互关系，然后画出修改的方法，既可以帮助你分析问题，又可以在面试的时候，帮助面试官清楚地看到你的思路。

#### 2.3 例题分析：

>25. K 个一组翻转链表
>
>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
>
>k 是一个正整数，它的值小于或等于链表的长度。
>
>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
>
>**示例：**
>
>```
>给你这个链表：1->2->3->4->5
>当 k = 2 时，应当返回: 2->1->4->3->5
>当 k = 3 时，应当返回: 3->2->1->4->5
>```
>
>**说明：**
>
>你的算法只能使用常数的额外空间。
>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**解题思路：**

这道题考察了两个知识点：

- 对链表翻转算法是否熟悉

- 对递归算法的理解是否清晰

在翻转链表的时候，可以借助三个指针：`prev`、`curr`、`next`，分别代表前一个节点、当前节点和下一个节点，整体算法步骤如下：

- 找到待翻转的k个节点（若剩余数量小于k的话，则不需要反转，因此直接返回待翻转部分的头结点即可）。 
- 对这k个节点反转,并返回翻转后的头结点：
    - 将 `curr `指向的下一节点保存到 next 指针；
    - `curr `指向 `prev`，一起前进一步；
    - 重复之前步骤，直到 k 个元素翻转完毕；
    - 当完成了局部的翻转后，`prev `就是最终的新的链表头，`curr `指向了下一个要被处理的局部，而原来的头指针 head 成为了链表的尾巴。
  
- 对下一轮k个节点也进行翻转操作。
- 将上一轮翻转后的尾结点指向下一轮翻转后的头节点。

例题的具体代码见 [ExampleSolution/Python/25_reverseKGroup.py]( https://github.com/moonlighf/AlgorithmWithLeetCode/blob/master/DataStructure/ExampleSolution/Python/25_reverseKGroup.py )
