# 数据结构篇——常用数据结构

### 01. 数组（Array）

&#8195;数组是最基本的数据结构，在很多编程语言中都有着十分相似的性质。

#### 1.1 数组的优缺点：

**数组的优点：**

- 构建非常简单

- 能在 O(1) 的时间里根据数组的下标（index）查询某个元素

**数组的缺点：**

- 构建时必须分配一段连续的空间

- 查询某个元素是否存在时需要遍历整个数组，耗费 O(n) 的时间

- 删除和添加某个元素时，同样需要耗费 O(n) 的时间

&#8195;所以，在考虑是否应采用数组辅助算法时，需要考虑它的缺点是否会影响**时间复杂度和空间复杂度。**

#### 1.2 例题分析

>242. 有效的字母异位词
>
>给定两个字符串 *s* 和 *t* ，编写一个函数来判断 *t* 是否是 *s* 的字母异位词。 
>
>**示例 1:**
>
>```
>输入: s = "anagram", t = "nagaram"
>输出: true
>```
>
>
>**示例 2:**
>
>```
>输入: s = "rat", t = "car"
>输出: false
>```
>
>**说明:**
>你可以假设字符串只包含小写字母。
>
>**解释：**
>
>字母异位词，也就是两个字符串中的相同字符的数量要对应相等。

**解题思路：**

一个重要的前提“假设两个字符串只包含小写字母”，小写字母一共也就 26 个，因此：

- 方法一：可以利用两个长度都为 26 的字符数组来统计每个字符串中小写字母出现的次数，然后再对比是否相等；

- 方法二：可以只利用一个长度为 26 的字符数组，将出现在字符串 s 里的字符个数加 1，而出现在字符串 t 里的字符个数减 1，最后判断每个小写字母的个数是否都为 0。
- 方法三：方法二中的数组可以换成哈希表
- 方法四：排序后判断是否相等

|            | 方法一 | 方法二 | 方法三 | 方法四   |
| ---------- | ------ | ------ | ------ | -------- |
| 时间复杂度 | O(n)   | O(n)   | O(n)   | O(nlogn) |
| 空间复杂度 | O(1)   | O(1)   | O(1)   | O(1)     |

**尽管我们使用了额外的空间，但是空间的复杂性是 O(1)，因为无论 N 有多大，表的大小都保持不变。** 

>**进阶：**
>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
>
>**解答：**
>使用哈希表而不是固定大小的计数器。想象一下，分配一个大的数组来适应整个 Unicode 字符范围，这个范围可能超过 100万。哈希表是一种更通用的解决方案，可以适应任何字符范围。**这里就体现出了数组的缺点**

例题的具体代码见 [Python/242_isAnagram.py]( https://github.com/moonlighf/AlgorithmWithLeetCode/blob/master/DataStructure/ExampleSolution/Python/242_isAnagram.py )

### 02. 链表（LinkedList）

**单链表**：链表中的每个元素是一个单独的对象，所有对象通过每个元素中的引用字段链接在一起。

**双链表**：与单链表不同的是，双链表的每个结点中都含有两个引用字段。

#### 2.1 链表的优缺点：

**链表的优点：**

- 链表能灵活地分配内存空间；

- 能在 O(1) 时间内删除或者添加元素，前提是该元素的前一个元素已知，当然也取决于是单链表还是双链表，在双链表中，如果已知该元素的后一个元素，同样可以在 O(1) 时间内删除或者添加该元素。

**链表的缺点是：**

- 不像数组能通过下标迅速读取元素，每次都要从链表头开始一个一个读取；

- 查询第 k 个元素需要 O(k) 时间。

**应用场景**：如果要解决的问题里面需要很多快速查询，链表可能并不适合；如果遇到的问题中，数据的元素个数不确定，而且需要经常进行数据的添加和删除，那么链表会比较合适。**而如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合。**

#### 2.2 链表经典解题方法：

链表是实现很多复杂数据结构的基础，经典解法如下：

1. **利用快慢指针（有时候需要用到三个指针）**

典型题目例如：链表的翻转，寻找倒数第 k 个元素，寻找链表中间位置的元素，判断链表是否有环等等。

2. **构建一个虚假的链表头**

&#8195;一般用在要返回新的链表的题目中，比如，给定两个排好序的链表，要求将它们整合在一起并排好序。又比如，将一个链表中的奇数和偶数按照原定的顺序分开后重新组合成一个新的链表，链表的头一半是奇数，后一半是偶数。

&#8195;在这类问题里，如果不用一个虚假的链表头，那么在创建新链表的第一个元素时，我们都得要判断一下链表的头指针是否为空，也就是要多写一条 if else 语句。比较简洁的写法是创建一个空的链表头，直接往其后面添加元素即可，最后返回这个空的链表头的下一个节点即可。

**专家建议**：在解决链表的题目时，可以在纸上或者白板上画出节点之间的相互关系，然后画出修改的方法，既可以帮助你分析问题，又可以在面试的时候，帮助面试官清楚地看到你的思路。

#### 2.3 例题分析：

>25. K 个一组翻转链表
>
>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
>
>k 是一个正整数，它的值小于或等于链表的长度。
>
>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
>
>**示例：**
>
>```
>给你这个链表：1->2->3->4->5
>当 k = 2 时，应当返回: 2->1->4->3->5
>当 k = 3 时，应当返回: 3->2->1->4->5
>```
>
>**说明：**
>
>你的算法只能使用常数的额外空间。
>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**解题思路：**

这道题考察了两个知识点：

- 对链表翻转算法是否熟悉

- 对递归算法的理解是否清晰

在翻转链表的时候，可以借助三个指针：`prev`、`curr`、`next`，分别代表前一个节点、当前节点和下一个节点，整体算法步骤如下：

- 找到待翻转的k个节点（若剩余数量小于k的话，则不需要反转，因此直接返回待翻转部分的头结点即可）。 
- 对这k个节点反转,并返回翻转后的头结点：
    - 将 `curr `指向的下一节点保存到 next 指针；
    - `curr `指向 `prev`，一起前进一步；
    - 重复之前步骤，直到 k 个元素翻转完毕；
    - 当完成了局部的翻转后，`prev `就是最终的新的链表头，`curr `指向了下一个要被处理的局部，而原来的头指针 head 成为了链表的尾巴。
  
- 对下一轮k个节点也进行翻转操作。
- 将上一轮翻转后的尾结点指向下一轮翻转后的头节点。

&#8195;例题的具体代码见 [Python/25_reverseKGroup.py]( https://github.com/moonlighf/AlgorithmWithLeetCode/blob/master/DataStructure/ExampleSolution/Python/25_reverseKGroup.py )，另外LeetCode24题和本例题相似，即本例题中`k=2`的情况，也一并做了解答，具体代码见 [Python//24_swapPairs.py]( https://github.com/moonlighf/AlgorithmWithLeetCode/blob/master/DataStructure/ExampleSolution/Python/24_swapPairs.py )

### 03. 栈（Stack）

&#8195;栈的最大特点就是后进先出（LIFO）。对于栈中的数据来说，所有操作都是在栈的顶部完成的，只可以查看栈顶部的元素，只能够向栈的顶部压⼊数据，也只能从栈的顶部弹出数据。

#### 3.1 实现和应用场景：

**实现**：利用一个单链表来实现栈的数据结构。而且，因为我们都只针对栈顶元素进行操作，所以借用单链表的头就能让所有栈的操作在 O(1) 的时间内完成。

**应用场景**：在解决某个问题的时候，只要求关心最近一次的操作，并且在操作完成了之后，需要向前查找到更前一次的操作。

如果打算用一个数组外加一个指针来实现相似的效果，那么，一旦数组的长度发生了改变，哪怕只是在最后添加一个新的元素，时间复杂度都不再是 O(1)，而且，空间复杂度也得不到优化。

注意：栈是许多 LeetCode 中等难度偏上的题目里面经常需要用到的数据结构，掌握好它是十分必要的。

#### 3.2 例题分析

>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
>
>有效字符串需满足：
>
>左括号必须用相同类型的右括号闭合。
>左括号必须以正确的顺序闭合。
>注意空字符串可被认为是有效字符串。
>
>**示例 1:**
>
>```
>输入: "()"
>输出: true
>```
>
>**示例 2:**
>
>```
>输入: "()[]{}"
>输出: true
>```
>
>**示例 3:**
>
>```
>输入: "(]"
>输出: false
>```
>
>**示例 4:**
>
>```
>输入: "([)]"
>输出: false
>```
>
>**示例 5:**
>
>```
>输入: "{[]}"
>输出: true
>```
>
>

**解题思路：**

利用一个栈，不断地往里压左括号，一旦遇上了一个右括号，我们就把栈顶的左括号弹出来，表示这是一个合法的组合，以此类推，直到最后判断栈里还有没有左括号剩余

![img](README.assets/CgoB5l2IRLSATKk3AMg-Ag7s3RA865.gif) 

>739.每日温度 
>
>请根据每日 `气温` 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。
>
>例如，给定一个列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是 `[1, 1, 4, 2, 1, 1, 0, 0]`。
>
>**提示：**`气温` 列表长度的范围是 `[1, 30000]`。每个气温的值的均为华氏度，都是在 `[30, 100]` 范围内的整数。

**解题思路：**

第一个温度值是 23 摄氏度，它要经过 1 天才能等到温度的升高，也就是在第二天的时候，温度升高到 24 摄氏度，所以对应的结果是 1。接下来，从 25 度到下一次温度的升高需要等待 4 天的时间，那时温度会变为 26 度。

- **思路 1**：最直观的做法就是针对每个温度值向后进行依次搜索，找到比当前温度更高的值，这样的计算复杂度就是 `O(n2)`。 

  但是，在这样的搜索过程中，产生了很多重复的对比。例如，从 25 度开始往后面寻找一个比 25 度更高的温度的过程中，经历了 21 度、19 度和 22 度，而这是一个温度由低到高的过程，也就是说在这个过程中已经找到了 19 度以及 21 度的答案，它就是 22 度。 

- **思路 2**：可以运用一个堆栈 stack 来快速地知道需要经过多少天就能等到温度升高。从头到尾扫描一遍给定的数组 T，如果当天的温度比堆栈 stack 顶端所记录的那天温度还要高，那么就能得到结果。

![img](README.assets/CgoB5l2IRMSAYv0mAJhTnwV5DmQ777-1595143630565.gif) 

1. 对第一个温度 23 度，堆栈为空，把它的下标压入堆栈；

2. 下一个温度 24 度，高于 23 度高，因此 23 度温度升高只需 1 天时间，把 23 度下标从堆栈里弹出，把 24 度下标压入；

3. 同样，从 24 度只需要 1 天时间升高到 25 度；

4. 21 度低于 25 度，直接把 21 度下标压入堆栈；

5. 19 度低于 21 度，压入堆栈；

6. 22 度高于 19 度，从 19 度升温只需 1 天，从 21 度升温需要 2 天；

7. 由于堆栈里保存的是下标，能很快计算天数；

8. 22 度低于 25 度，意味着尚未找到 25 度之后的升温，直接把 22 度下标压入堆栈顶端；
9. 后面的温度与此同理。


该方法只需要对数组进行一次遍历，每个元素最多被压入和弹出堆栈一次，算法复杂度是 O(n)。

利用堆栈，还可以解决如下常见问题：

- 求解算术表达式的结果（LeetCode 224、227、772、770)

- 求解直方图里最大的矩形区域（LeetCode 84）

